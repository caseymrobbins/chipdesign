#!/usr/bin/env python3
"""
EXPLOIT HEADROOM VIA MARGIN THRESHOLD
KEY INSIGHT: min_margin_threshold is the real performance bottleneck!

Current state: All Softmin configs (Î»=0.05-0.50, Î²=1.0-6.0) â†’ 47.04 perf
Reason: min_margin_threshold=2.0 forces conservative behavior
Solution: Sweep min_margin_threshold from aggressive (0.1) to conservative (2.0)

Goal: Find threshold that maximizes (performance Ã— survival)
"""

import json
import numpy as np
from typing import List, Tuple, Dict, Optional
from advanced_chip_simulator import (
    AdvancedDesignSpace,
    AdvancedAgent,
    DesignAction,
    ProcessTechnology,
    AdvancedSimulation,
    ShiftType,
    AdvancedGreedyPerformanceAgent,
)
from dataclasses import asdict


def softmin(values: np.ndarray, beta: float = 1.0) -> float:
    """Compute smooth softmin approximation."""
    v_shifted = values - np.max(values)
    weights = np.exp(-beta * v_shifted)
    weights_sum = np.sum(weights)
    result = np.sum(values * weights) / weights_sum
    return result


class SoftminJAMAgent(AdvancedAgent):
    """JAM agent using softmin instead of hard min."""

    def __init__(
        self,
        lambda_weight: float = 1.0,
        beta: float = 2.0,
        min_margin_threshold: float = 2.0,
        epsilon: float = 0.01,
    ):
        super().__init__(f"SoftminJAM(Î»={lambda_weight},Î²={beta},margin={min_margin_threshold})")
        self.lambda_weight = lambda_weight
        self.beta = beta
        self.min_margin_threshold = min_margin_threshold
        self.epsilon = epsilon

    def calculate_objective(self, headrooms_dict: Dict[str, float]) -> float:
        """Calculate R = sum(headrooms) + Î» * log(softmin(headrooms; Î²) + Îµ)"""
        weights = self.design_space.limits.constraint_weights
        weighted_headrooms = {
            constraint: headroom * weights.get(constraint, 1.0)
            for constraint, headroom in headrooms_dict.items()
        }

        headroom_values = np.array(list(weighted_headrooms.values()))

        if np.any(headroom_values <= 0):
            return -np.inf

        sum_term = np.sum(headroom_values)
        softmin_val = softmin(headroom_values, beta=self.beta)
        softmin_term = self.lambda_weight * np.log(softmin_val + self.epsilon)

        return sum_term + softmin_term

    def select_action(self) -> Optional[DesignAction]:
        """Select action that maximizes the new objective"""
        if not self.design_space:
            return None

        current_headrooms = self.design_space.get_headrooms()
        current_objective = self.calculate_objective(current_headrooms)

        safe_actions = []
        risky_actions = []

        for action in self.design_space.actions:
            test_space = self.design_space.clone()
            test_space.apply_action(action)

            if not test_space.is_feasible():
                continue

            headrooms = test_space.get_headrooms()
            min_headroom = min(headrooms.values())
            objective_score = self.calculate_objective(headrooms)
            perf = test_space.calculate_performance()

            action_data = (action, objective_score, perf, min_headroom)

            if min_headroom >= self.min_margin_threshold:
                safe_actions.append(action_data)
            else:
                risky_actions.append(action_data)

        if safe_actions:
            best = max(safe_actions, key=lambda x: (x[1], x[2]))
            return best[0]

        elif risky_actions:
            improving = [a for a in risky_actions if a[3] >= min(current_headrooms.values())]
            if improving:
                best = max(improving, key=lambda x: (x[1], x[2]))
                return best[0]
            else:
                best = max(risky_actions, key=lambda x: x[3])
                return best[0]

        return None


def run_margin_threshold_sweep(num_runs=50):
    """Test different min_margin_threshold values to exploit headroom"""

    print("="*80)
    print("MARGIN THRESHOLD SWEEP")
    print("="*80)
    print("THE REAL BOTTLENECK: min_margin_threshold forces conservative behavior!")
    print("Current: threshold=2.0 â†’ 47.04 perf, 84.6% headroom (MASSIVE WASTE!)")
    print("Goal: Find optimal threshold that maximizes (performance Ã— survival)")
    print("="*80)

    # Sweep margin thresholds from aggressive to conservative
    configs = [
        # ULTRA AGGRESSIVE - minimal safety margin
        {"margin": 0.10, "name": "UltraAggr(margin=0.10)"},
        {"margin": 0.25, "name": "VeryAggr(margin=0.25)"},
        {"margin": 0.50, "name": "Aggressive(margin=0.50)"},

        # MODERATE - balanced
        {"margin": 0.75, "name": "ModAggr(margin=0.75)"},
        {"margin": 1.00, "name": "Moderate(margin=1.00)"},
        {"margin": 1.25, "name": "ModCons(margin=1.25)"},

        # CONSERVATIVE - current default
        {"margin": 1.50, "name": "Conservative(margin=1.50)"},
        {"margin": 2.00, "name": "VeryConservative(margin=2.00)"},

        # Baseline
        {"margin": 0.0, "name": "Greedy"},
    ]

    # Use optimal Softmin parameters from previous tests
    LAMBDA = 0.05
    BETA = 1.0

    results = {}
    process = ProcessTechnology.create_7nm()

    for config in configs:
        print(f"\n{'='*60}")
        print(f"Testing {config['name']}")
        print(f"{'='*60}")

        perf_scores = []
        survival_count = 0
        efficiencies = []
        headrooms = []
        powers = []
        clocks = []

        for run in range(num_runs):
            # Create design space
            seed = run * 1000 + int(config['margin'] * 1000)
            space = AdvancedDesignSpace(process=process, seed=seed)
            space.initialize_actions()

            # Create agent
            if config['margin'] > 0:
                agent = SoftminJAMAgent(
                    lambda_weight=LAMBDA,
                    beta=BETA,
                    min_margin_threshold=config['margin']
                )
            else:
                agent = AdvancedGreedyPerformanceAgent()

            agent.initialize(space)

            # Run design phase (100 steps)
            for step in range(100):
                agent.step()

            # Store design performance
            design_perf = space.calculate_performance()
            perf_scores.append(design_perf)

            # Store metrics
            if space.is_feasible():
                constraints = space.calculate_constraints()
                efficiencies.append(design_perf / constraints['total_power_w'])
                headrooms.append(space.get_min_headroom())
                powers.append(constraints['total_power_w'])
                clocks.append(space.params.clock_freq_ghz)

            # Apply random requirement shift
            shift_rng = np.random.RandomState(run * 9999 + int(config['margin'] * 10000))
            shift_type = shift_rng.choice(list(ShiftType))
            space.apply_requirement_shift(shift_type, shift_rng)

            # Check survival
            if space.is_feasible():
                survival_count += 1

            # Progress indicator
            if (run + 1) % 10 == 0:
                survival_rate = survival_count / (run + 1)
                avg_perf = np.mean(perf_scores)
                print(f"  Run {run+1}/{num_runs}: Perf={avg_perf:.1f}, Survival={survival_rate*100:.0f}%")

        # Calculate statistics
        survival_rate = survival_count / num_runs
        avg_perf = np.mean(perf_scores)
        avg_eff = np.mean(efficiencies) if efficiencies else 0
        avg_headroom = np.mean(headrooms) if headrooms else 0
        avg_power = np.mean(powers) if powers else 0
        avg_clock = np.mean(clocks) if clocks else 0

        # Calculate combined score: perf Ã— survival (our optimization target)
        combined_score = avg_perf * survival_rate

        results[config['name']] = {
            'margin': config['margin'],
            'performance': avg_perf,
            'survival_rate': survival_rate,
            'efficiency': avg_eff,
            'headroom': avg_headroom,
            'power': avg_power,
            'clock': avg_clock,
            'combined_score': combined_score,
            'num_runs': num_runs
        }

        print(f"\n  RESULTS:")
        print(f"    Performance:     {avg_perf:.2f}")
        print(f"    Survival:        {survival_rate*100:.1f}%")
        print(f"    Combined Score:  {combined_score:.2f} (perfÃ—survival)")
        print(f"    Efficiency:      {avg_eff:.2f} perf/W")
        print(f"    Headroom:        {avg_headroom*100:.1f}%")
        print(f"    Power:           {avg_power:.2f}W")
        print(f"    Clock:           {avg_clock:.2f}GHz")

    return results


def analyze_margin_sweep(results: Dict) -> None:
    """Analyze margin threshold sweep results"""

    print(f"\n{'='*80}")
    print("SUMMARY: MARGIN THRESHOLD VS PERFORMANCE")
    print(f"{'='*80}\n")

    print(f"{'Config':<30} {'Margin':<10} {'Perf':<10} {'Survival':<12} {'Score':<12} {'Headroom':<10}")
    print("-" * 90)

    for name, metrics in sorted(results.items(), key=lambda x: x[1]['performance'], reverse=True):
        print(f"{name:<30} {metrics['margin']:>8.2f}   {metrics['performance']:>8.1f}   "
              f"{metrics['survival_rate']*100:>9.1f}%   {metrics['combined_score']:>10.1f}   "
              f"{metrics['headroom']*100:>8.1f}%")

    # Find sweet spot: max combined score
    print(f"\n{'='*80}")
    print("OPTIMIZATION RESULTS")
    print(f"{'='*80}\n")

    best_combined = max(results.items(), key=lambda x: x[1]['combined_score'])
    best_perf = max(results.items(), key=lambda x: x[1]['performance'])
    best_survival = max(results.items(), key=lambda x: x[1]['survival_rate'])

    print(f"ðŸ† BEST COMBINED SCORE (perf Ã— survival): {best_combined[0]}")
    print(f"   Margin:      {best_combined[1]['margin']:.2f}")
    print(f"   Performance: {best_combined[1]['performance']:.1f}")
    print(f"   Survival:    {best_combined[1]['survival_rate']*100:.1f}%")
    print(f"   Score:       {best_combined[1]['combined_score']:.1f}")

    print(f"\nâš¡ BEST PERFORMANCE: {best_perf[0]}")
    print(f"   Margin:      {best_perf[1]['margin']:.2f}")
    print(f"   Performance: {best_perf[1]['performance']:.1f}")
    print(f"   Survival:    {best_perf[1]['survival_rate']*100:.1f}%")

    print(f"\nðŸ›¡ï¸  BEST SURVIVAL: {best_survival[0]}")
    print(f"   Margin:      {best_survival[1]['margin']:.2f}")
    print(f"   Performance: {best_survival[1]['performance']:.1f}")
    print(f"   Survival:    {best_survival[1]['survival_rate']*100:.1f}%")

    # Headroom analysis
    print(f"\n{'='*80}")
    print("HEADROOM UTILIZATION")
    print(f"{'='*80}\n")

    print("As margin threshold decreases, we SHOULD see:")
    print("  1. Higher performance (exploiting the headroom)")
    print("  2. Lower headroom (using available budget)")
    print("  3. Some decrease in survival (acceptable trade-off)")
    print()

    for name, metrics in sorted(results.items(), key=lambda x: x[1]['margin']):
        if metrics['margin'] > 0:  # Skip Greedy
            print(f"{name:<30} Margin={metrics['margin']:.2f}: "
                  f"Perf={metrics['performance']:.1f}, Headroom={metrics['headroom']*100:.1f}%")


if __name__ == "__main__":
    print("\n" + "="*80)
    print("HEADROOM EXPLOITATION VIA MARGIN THRESHOLD SWEEP")
    print("="*80)
    print("\nKEY INSIGHT:")
    print("  Previous experiments showed Î» and Î² don't matter when margin threshold is too high!")
    print("  All configs (Î»=0.05-0.50, Î²=1.0-6.0) â†’ 47.04 perf, 84.6% headroom")
    print("\nSOLUTION:")
    print("  Sweep min_margin_threshold from aggressive (0.1) to conservative (2.0)")
    print("  Find the sweet spot that maximizes (performance Ã— survival)")
    print("="*80 + "\n")

    # Run the sweep
    results = run_margin_threshold_sweep(num_runs=50)

    # Save results
    with open('margin_threshold_results.json', 'w') as f:
        json.dump(results, f, indent=2)

    # Analyze
    analyze_margin_sweep(results)

    print(f"\n{'='*80}")
    print("Results saved to: margin_threshold_results.json")
    print(f"{'='*80}\n")
