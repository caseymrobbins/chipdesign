#!/usr/bin/env python3
"""
EXPLOIT HEADROOM: Push performance higher by leveraging the 56.6% headroom
Goal: Find the sweet spot between Softmin (70 perf, 100% survival) and Greedy (94 perf, 51% survival)
Target: 80-90 performance with 70-85% survival
"""

import json
import numpy as np
from typing import List, Tuple, Dict, Optional
from advanced_chip_simulator import (
    AdvancedDesignSpace,
    AdvancedAgent,
    DesignAction,
    ProcessTechnology,
    AdvancedSimulation,
    ShiftType,
    AdvancedGreedyPerformanceAgent,
)
from dataclasses import asdict


def softmin(values: np.ndarray, beta: float = 1.0) -> float:
    """Compute smooth softmin approximation."""
    v_shifted = values - np.max(values)
    weights = np.exp(-beta * v_shifted)
    weights_sum = np.sum(weights)
    result = np.sum(values * weights) / weights_sum
    return result


class SoftminJAMAgent(AdvancedAgent):
    """JAM agent using softmin instead of hard min."""

    def __init__(
        self,
        lambda_weight: float = 1.0,
        beta: float = 2.0,
        min_margin_threshold: float = 2.0,
        epsilon: float = 0.01,
    ):
        super().__init__(f"SoftminJAM(Œª={lambda_weight},Œ≤={beta})")
        self.lambda_weight = lambda_weight
        self.beta = beta
        self.min_margin_threshold = min_margin_threshold
        self.epsilon = epsilon

    def calculate_objective(self, headrooms_dict: Dict[str, float]) -> float:
        """Calculate R = sum(headrooms) + Œª * log(softmin(headrooms; Œ≤) + Œµ)"""
        weights = self.design_space.limits.constraint_weights
        weighted_headrooms = {
            constraint: headroom * weights.get(constraint, 1.0)
            for constraint, headroom in headrooms_dict.items()
        }

        headroom_values = np.array(list(weighted_headrooms.values()))

        if np.any(headroom_values <= 0):
            return -np.inf

        sum_term = np.sum(headroom_values)
        softmin_val = softmin(headroom_values, beta=self.beta)
        softmin_term = self.lambda_weight * np.log(softmin_val + self.epsilon)

        return sum_term + softmin_term

    def select_action(self) -> Optional[DesignAction]:
        """Select action that maximizes the new objective"""
        if not self.design_space:
            return None

        current_headrooms = self.design_space.get_headrooms()
        current_objective = self.calculate_objective(current_headrooms)

        safe_actions = []
        risky_actions = []

        for action in self.design_space.actions:
            test_space = self.design_space.clone()
            test_space.apply_action(action)

            if not test_space.is_feasible():
                continue

            headrooms = test_space.get_headrooms()
            min_headroom = min(headrooms.values())
            objective_score = self.calculate_objective(headrooms)
            perf = test_space.calculate_performance()

            action_data = (action, objective_score, perf, min_headroom)

            if min_headroom >= self.min_margin_threshold:
                safe_actions.append(action_data)
            else:
                risky_actions.append(action_data)

        if safe_actions:
            best = max(safe_actions, key=lambda x: (x[1], x[2]))
            return best[0]

        elif risky_actions:
            improving = [a for a in risky_actions if a[3] >= min(current_headrooms.values())]
            if improving:
                best = max(improving, key=lambda x: (x[1], x[2]))
                return best[0]
            else:
                best = max(risky_actions, key=lambda x: x[3])
                return best[0]

        return None

def run_aggressive_softmin_sweep(num_runs=50):
    """Test aggressive Softmin parameters to exploit headroom"""

    # AGGRESSIVE parameter sweep - push harder than before!
    configs = [
        # Previous best (baseline)
        {"lambda": 0.05, "beta": 1.0, "name": "Conservative(Œª=0.05,Œ≤=1.0)"},

        # Moderate push
        {"lambda": 0.10, "beta": 1.5, "name": "Moderate(Œª=0.10,Œ≤=1.5)"},
        {"lambda": 0.12, "beta": 1.8, "name": "Moderate+(Œª=0.12,Œ≤=1.8)"},

        # Aggressive push - exploit that headroom!
        {"lambda": 0.15, "beta": 2.0, "name": "Aggressive(Œª=0.15,Œ≤=2.0)"},
        {"lambda": 0.18, "beta": 2.3, "name": "Aggressive+(Œª=0.18,Œ≤=2.3)"},
        {"lambda": 0.20, "beta": 2.5, "name": "Aggressive++(Œª=0.20,Œ≤=2.5)"},

        # ULTRA aggressive - push to the limit!
        {"lambda": 0.25, "beta": 3.0, "name": "Ultra(Œª=0.25,Œ≤=3.0)"},
        {"lambda": 0.30, "beta": 3.5, "name": "Ultra+(Œª=0.30,Œ≤=3.5)"},
        {"lambda": 0.35, "beta": 4.0, "name": "Ultra++(Œª=0.35,Œ≤=4.0)"},

        # EXTREME - approach Greedy territory
        {"lambda": 0.40, "beta": 5.0, "name": "Extreme(Œª=0.40,Œ≤=5.0)"},
        {"lambda": 0.50, "beta": 6.0, "name": "Extreme+(Œª=0.50,Œ≤=6.0)"},

        # Baseline for comparison
        {"lambda": 0.0, "beta": 0.0, "name": "Greedy"},
    ]

    results = {}
    process = ProcessTechnology.create_7nm()

    for config in configs:
        print(f"\n{'='*60}")
        print(f"Testing {config['name']}")
        print(f"{'='*60}")

        perf_scores = []
        survival_count = 0
        efficiencies = []
        headrooms = []
        powers = []
        clocks = []

        for run in range(num_runs):
            # Create design space
            seed = run * 1000 + int(config['lambda'] * 1000) + int(config['beta'] * 100)
            space = AdvancedDesignSpace(process=process, seed=seed)
            space.initialize_actions()

            # Create agent
            if config['lambda'] > 0:
                agent = SoftminJAMAgent(
                    lambda_weight=config['lambda'],
                    beta=config['beta'],
                    min_margin_threshold=2.0
                )
            else:
                agent = AdvancedGreedyPerformanceAgent()

            agent.initialize(space)

            # Run design phase (100 steps)
            for step in range(100):
                agent.step()

            # Store design performance
            design_perf = space.calculate_performance()
            perf_scores.append(design_perf)

            # Store metrics
            if space.is_feasible():
                constraints = space.calculate_constraints()
                efficiencies.append(design_perf / constraints['total_power_w'])
                headrooms.append(space.get_min_headroom())
                powers.append(constraints['total_power_w'])
                clocks.append(space.params.clock_freq_ghz)

            # Apply random requirement shift
            shift_rng = np.random.RandomState(run * 9999 + int(config['lambda'] * 10000))
            shift_type = shift_rng.choice(list(ShiftType))
            space.apply_requirement_shift(shift_type, shift_rng)

            # Check survival
            if space.is_feasible():
                survival_count += 1

            # Progress indicator
            if (run + 1) % 10 == 0:
                survival_rate = survival_count / (run + 1)
                avg_perf = np.mean(perf_scores)
                print(f"  Run {run+1}/{num_runs}: Perf={avg_perf:.1f}, Survival={survival_rate*100:.0f}%")

        # Calculate statistics
        survival_rate = survival_count / num_runs
        avg_perf = np.mean(perf_scores)
        avg_eff = np.mean(efficiencies) if efficiencies else 0
        avg_headroom = np.mean(headrooms) if headrooms else 0
        avg_power = np.mean(powers) if powers else 0
        avg_clock = np.mean(clocks) if clocks else 0

        results[config['name']] = {
            'lambda': config['lambda'],
            'beta': config['beta'],
            'performance': avg_perf,
            'survival_rate': survival_rate,
            'efficiency': avg_eff,
            'headroom': avg_headroom,
            'power': avg_power,
            'clock': avg_clock,
            'num_runs': num_runs
        }

        print(f"\n  RESULTS:")
        print(f"    Performance:   {avg_perf:.2f}")
        print(f"    Survival:      {survival_rate*100:.1f}%")
        print(f"    Efficiency:    {avg_eff:.2f} perf/W")
        print(f"    Headroom:      {avg_headroom*100:.1f}%")
        print(f"    Power:         {avg_power:.2f}W")
        print(f"    Clock:         {avg_clock:.2f}GHz")

    return results

def find_pareto_frontier(results):
    """Find Pareto optimal configurations (max perf for given survival rate)"""

    print(f"\n{'='*80}")
    print("PARETO FRONTIER ANALYSIS")
    print(f"{'='*80}\n")

    # Sort by survival rate
    sorted_configs = sorted(results.items(), key=lambda x: x[1]['survival_rate'], reverse=True)

    pareto_frontier = []
    max_perf_seen = 0

    for name, metrics in sorted_configs:
        if metrics['performance'] > max_perf_seen:
            pareto_frontier.append((name, metrics))
            max_perf_seen = metrics['performance']

    print("Pareto Optimal Configurations (best perf at each survival level):")
    print(f"{'Config':<30} {'Performance':<12} {'Survival':<12} {'Efficiency':<12} {'Headroom':<10}")
    print("-" * 80)

    for name, metrics in pareto_frontier:
        print(f"{name:<30} {metrics['performance']:>10.1f}   {metrics['survival_rate']*100:>9.1f}%   "
              f"{metrics['efficiency']:>10.2f}   {metrics['headroom']*100:>8.1f}%")

    return pareto_frontier

def identify_sweet_spot(results):
    """Find the best trade-off: maximize (performance √ó survival)"""

    print(f"\n{'='*80}")
    print("SWEET SPOT ANALYSIS")
    print(f"{'='*80}\n")

    # Calculate combined score: perf √ó survival
    scored = []
    for name, metrics in results.items():
        score = metrics['performance'] * metrics['survival_rate']
        scored.append((name, metrics, score))

    # Sort by combined score
    scored.sort(key=lambda x: x[2], reverse=True)

    print("Top 5 Configurations (optimizing perf √ó survival):")
    print(f"{'Config':<30} {'Score':<10} {'Perf':<10} {'Survival':<12} {'Efficiency':<12}")
    print("-" * 80)

    for name, metrics, score in scored[:5]:
        print(f"{name:<30} {score:>8.1f}   {metrics['performance']:>8.1f}   "
              f"{metrics['survival_rate']*100:>9.1f}%   {metrics['efficiency']:>10.2f}")

    # Also show perf √ó survival √ó efficiency
    print(f"\n{'='*80}")
    print("ULTIMATE OPTIMIZATION: perf √ó survival √ó efficiency")
    print(f"{'='*80}\n")

    scored_ultimate = []
    for name, metrics in results.items():
        score = metrics['performance'] * metrics['survival_rate'] * metrics['efficiency']
        scored_ultimate.append((name, metrics, score))

    scored_ultimate.sort(key=lambda x: x[2], reverse=True)

    print(f"{'Config':<30} {'Score':<12} {'Perf':<10} {'Survival':<12} {'Efficiency':<12}")
    print("-" * 80)

    for name, metrics, score in scored_ultimate[:5]:
        print(f"{name:<30} {score:>10.1f}   {metrics['performance']:>8.1f}   "
              f"{metrics['survival_rate']*100:>9.1f}%   {metrics['efficiency']:>10.2f}")

    return scored[0], scored_ultimate[0]

if __name__ == "__main__":
    print("HEADROOM EXPLOITATION EXPERIMENT")
    print("="*80)
    print("Current state: 56.6% headroom means we're too conservative!")
    print("Goal: Push from 70 perf ‚Üí 80-90 perf while maintaining 70-85% survival")
    print("="*80)

    # Run the sweep
    results = run_aggressive_softmin_sweep(num_runs=50)

    # Save results
    with open('headroom_exploitation_results.json', 'w') as f:
        json.dump(results, f, indent=2)

    print(f"\n{'='*80}")
    print("SUMMARY OF ALL CONFIGURATIONS")
    print(f"{'='*80}\n")

    print(f"{'Config':<30} {'Perf':<10} {'Survival':<12} {'Efficiency':<12} {'Headroom':<10} {'Power':<8}")
    print("-" * 90)

    for name, metrics in sorted(results.items(), key=lambda x: x[1]['performance'], reverse=True):
        print(f"{name:<30} {metrics['performance']:>8.1f}   {metrics['survival_rate']*100:>9.1f}%   "
              f"{metrics['efficiency']:>10.2f}   {metrics['headroom']*100:>8.1f}%   {metrics['power']:>6.2f}W")

    # Find Pareto frontier
    pareto = find_pareto_frontier(results)

    # Find sweet spots
    sweet_spot_ps, sweet_spot_pse = identify_sweet_spot(results)

    print(f"\n{'='*80}")
    print("FINAL RECOMMENDATIONS")
    print(f"{'='*80}")
    print(f"\nüéØ Best Perf√óSurvival: {sweet_spot_ps[0]}")
    print(f"   Performance: {sweet_spot_ps[1]['performance']:.1f}")
    print(f"   Survival:    {sweet_spot_ps[1]['survival_rate']*100:.1f}%")
    print(f"   Efficiency:  {sweet_spot_ps[1]['efficiency']:.2f} perf/W")

    print(f"\nüèÜ Best Perf√óSurvival√óEfficiency: {sweet_spot_pse[0]}")
    print(f"   Performance: {sweet_spot_pse[1]['performance']:.1f}")
    print(f"   Survival:    {sweet_spot_pse[1]['survival_rate']*100:.1f}%")
    print(f"   Efficiency:  {sweet_spot_pse[1]['efficiency']:.2f} perf/W")

    print("\n" + "="*80)
    print("Results saved to: headroom_exploitation_results.json")
    print("="*80)
