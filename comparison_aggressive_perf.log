
================================================================================
GREEDY vs PURE INTRINSIC OPTIMIZATION COMPARISON
================================================================================
Runs: 50
Design steps: 75
Adaptation steps: 25

Agents being tested:
  1. Greedy - Maximizes immediate performance gain
  2. JAM (hard min) - Pure log(min(headroom)) optimization
  3. AdaptiveJAM - Two-phase: build margins, then push performance
  4. HybridJAM (λ=5) - Aggressive: low penalty for max performance
  5. SoftminJAM (λ=0.1,β=1.0) - Minimal penalty: MAXIMUM PERFORMANCE
  6. SoftminJAM (λ=0.5,β=1.5) - Light penalty: high performance focus
  7. SoftminJAM (λ=1.0,β=2.0) - Moderate: balanced performance
  8. SoftminJAM (λ=2.0,β=2.5) - Conservative: prioritize survival

✓ ALL agents use PURE intrinsic optimization (NO external constraints)
================================================================================

Completed 10/50 runs...
Completed 20/50 runs...
Completed 30/50 runs...
Completed 40/50 runs...
Completed 50/50 runs...

================================================================================
DETAILED STATISTICS
================================================================================

Greedy
------
  Design Phase:
    Performance:       93.90 ±  0.00
    Efficiency:         8.54 ±  0.00 perf/W
    Power:             10.99 ±  0.00 W
    Min Headroom:       0.42 ±  0.00
  Robustness:
    Survival Rate:     42.0% (21/50)

JAM (pure log-min)
------------------
  Design Phase:
/usr/local/lib/python3.11/dist-packages/numpy/_core/fromnumeric.py:3860: RuntimeWarning: Mean of empty slice.
  return _methods._mean(a, axis=axis, dtype=dtype,
/usr/local/lib/python3.11/dist-packages/numpy/_core/_methods.py:144: RuntimeWarning: invalid value encountered in scalar divide
  ret = ret.dtype.type(ret / rcount)
/usr/local/lib/python3.11/dist-packages/numpy/_core/_methods.py:222: RuntimeWarning: Degrees of freedom <= 0 for slice
  ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
/usr/local/lib/python3.11/dist-packages/numpy/_core/_methods.py:180: RuntimeWarning: invalid value encountered in divide
  arrmean = um.true_divide(arrmean, div, out=arrmean,
/usr/local/lib/python3.11/dist-packages/numpy/_core/_methods.py:214: RuntimeWarning: invalid value encountered in scalar divide
  ret = ret.dtype.type(ret / rcount)
    Performance:         nan ±   nan
    Efficiency:          nan ±   nan perf/W
    Power:               nan ±   nan W
    Min Headroom:        nan ±   nan
  Robustness:
    Survival Rate:      nan% (0/0)

AdaptiveJAM
-----------
  Design Phase:
    Performance:       47.08 ±  0.00
    Efficiency:         4.01 ±  0.00 perf/W
    Power:             11.74 ±  0.00 W
    Min Headroom:       0.97 ±  0.00
  Robustness:
    Survival Rate:     54.0% (27/50)

HybridJAM (λ=1000)
------------------
  Design Phase:
    Performance:         nan ±   nan
    Efficiency:          nan ±   nan perf/W
    Power:               nan ±   nan W
    Min Headroom:        nan ±   nan
  Robustness:
    Survival Rate:      nan% (0/0)

Traceback (most recent call last):
  File "/home/user/chipdesign/compare_greedy_vs_intrinsic.py", line 597, in <module>
    create_comparison_visualization(all_results, "greedy_vs_intrinsic.png")
  File "/home/user/chipdesign/compare_greedy_vs_intrinsic.py", line 331, in create_comparison_visualization
    create_boxplot(ax1, perf_data, positions,
  File "/home/user/chipdesign/compare_greedy_vs_intrinsic.py", line 312, in create_boxplot
    ax.set_xticklabels(['Greedy', 'JAM\n(hard)', 'Adaptive\nJAM', 'Hybrid\nJAM',
  File "/usr/local/lib/python3.11/dist-packages/matplotlib/axes/_base.py", line 74, in wrapper
    return get_method(self)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/matplotlib/axis.py", line 2106, in set_ticklabels
    raise ValueError(
ValueError: The number of FixedLocator locations (8), usually from a call to set_ticks, does not match the number of labels (7).
